#!/usr/bin/env bash
#
# phi_epsilon - Task management CLI for AI agents
# Compatible with existing phi epsilon.db schema (TEXT columns)
#
set -euo pipefail

# ─────────────────────────────────────────────────────────────────
# Configuration
# ─────────────────────────────────────────────────────────────────
if [[ -n "${PHI_EPSILON_DATA_DIR:-}" ]]; then
    DATA_DIR="$PHI_EPSILON_DATA_DIR"
else
    # Project-specific storage: ~/.local/share/phi/projects/<project-root-dir>/
    # Use git common dir for worktree support, fallback to pwd
    if GIT_ROOT="$(git rev-parse --git-common-dir 2>/dev/null)" && [[ "$GIT_ROOT" != ".git" ]]; then
        PROJECT_ROOT_DIR="$(cd "$GIT_ROOT" && pwd | sed 's|^/||; s|/|_|g')"
    else
        PROJECT_ROOT_DIR="$(pwd | sed 's|^/||; s|/|_|g')"
    fi
    DATA_DIR="$HOME/.local/share/phi/projects/${PROJECT_ROOT_DIR}"
fi
DB_FILE="${DATA_DIR}/epsilon.db"

EXIT_OK=0
EXIT_INVALID_ARGS=1
EXIT_NOT_FOUND=2
EXIT_DB_ERROR=3

# Valid status and priority values (canonical strings)
VALID_STATUSES="todo in_progress blocked done cancelled"
VALID_PRIORITIES="low medium high critical"

# Schema version: bump when schema changes
SCHEMA_VERSION=2

# ─────────────────────────────────────────────────────────────────
# Helpers
# ─────────────────────────────────────────────────────────────────
die() { echo "error: $1" >&2; exit "${2:-$EXIT_INVALID_ARGS}"; }
log() { echo "epsilon: $*" >&2; }

table_exists() {
    [[ "$(sql "SELECT 1 FROM sqlite_master WHERE type='table' AND name='$1' LIMIT 1;")" == "1" ]]
}

get_schema_version() {
    if ! table_exists "schema_version"; then
        echo 0
        return
    fi
    local v
    v="$(sql "SELECT version FROM schema_version WHERE id=1 LIMIT 1;")"
    echo "${v:-0}"
}

ensure_schema_version_table() {
    sql "CREATE TABLE IF NOT EXISTS schema_version (
        id INTEGER PRIMARY KEY DEFAULT 1 CHECK (id = 1),
        version INTEGER NOT NULL
    );"
}

backup_db() {
    local bak="${DB_FILE}.bak"
    log "backup: $DB_FILE -> $bak"
    cp -p "$DB_FILE" "$bak"
}

migrate_to_v2() {
    log "migrate v1 -> v2: validating data"

    # Preflight: fix any invalid status values
    local bad_status
    bad_status="$(sql "SELECT COUNT(*) FROM tasks WHERE status NOT IN ('todo','in_progress','blocked','done','cancelled');")"
    if [[ "${bad_status:-0}" != "0" ]]; then
        log "fixing $bad_status rows with invalid status"
        sql "UPDATE tasks SET status = CASE
            WHEN lower(trim(status)) IN ('wip','inprogress') THEN 'in_progress'
            WHEN lower(trim(status)) IN ('complete','completed') THEN 'done'
            WHEN lower(trim(status)) IN ('drop','cancel','canceled') THEN 'cancelled'
            ELSE 'todo'
        END
        WHERE status NOT IN ('todo','in_progress','blocked','done','cancelled');"
    fi

    # Preflight: fix any invalid priority values
    local bad_priority
    bad_priority="$(sql "SELECT COUNT(*) FROM tasks WHERE priority NOT IN ('low','medium','high','critical');")"
    if [[ "${bad_priority:-0}" != "0" ]]; then
        log "fixing $bad_priority rows with invalid priority"
        sql "UPDATE tasks SET priority = CASE
            WHEN lower(trim(priority)) IN ('med') THEN 'medium'
            WHEN lower(trim(priority)) IN ('urgent') THEN 'critical'
            ELSE 'medium'
        END
        WHERE priority NOT IN ('low','medium','high','critical');"
    fi

    # Rebuild table with CHECK constraints inside a transaction
    log "rebuilding tasks table with CHECK constraints"
    sqlite3 -batch -bail -cmd ".output /dev/null" -cmd "PRAGMA busy_timeout = 5000;" -cmd "PRAGMA journal_mode = WAL;" -cmd "PRAGMA foreign_keys = OFF;" -cmd ".output stdout" "$DB_FILE" <<'MIGRATION'

BEGIN IMMEDIATE;

DROP TABLE IF EXISTS tasks_new;

CREATE TABLE tasks_new (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    title TEXT NOT NULL,
    description TEXT,
    status TEXT NOT NULL DEFAULT 'todo'
        CHECK(status IN ('todo','in_progress','blocked','done','cancelled')),
    priority TEXT DEFAULT 'medium'
        CHECK(priority IN ('low','medium','high','critical')),
    tags TEXT,
    parent_id INTEGER,
    created_at INTEGER NOT NULL,
    updated_at INTEGER NOT NULL,
    completed_at INTEGER,
    FOREIGN KEY (parent_id) REFERENCES tasks_new(id) ON DELETE CASCADE
);

INSERT INTO tasks_new (id, title, description, status, priority, tags, parent_id, created_at, updated_at, completed_at)
SELECT id, title, description, status, priority, tags, parent_id, created_at, updated_at, completed_at
FROM tasks;

DROP TABLE tasks;
ALTER TABLE tasks_new RENAME TO tasks;

CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_parent ON tasks(parent_id);
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON tasks(priority);

CREATE TABLE IF NOT EXISTS schema_version (
    id INTEGER PRIMARY KEY DEFAULT 1 CHECK (id = 1),
    version INTEGER NOT NULL
);
INSERT OR REPLACE INTO schema_version (id, version) VALUES (1, 2);

COMMIT;
MIGRATION

    log "migration complete (schema_version=2)"
}

ensure_db() {
    mkdir -p "$DATA_DIR"

    if [[ ! -f "$DB_FILE" ]]; then
        init_db
        log "init new db (v$SCHEMA_VERSION): $DB_FILE"
        return
    fi

    # Existing DB: check version and migrate if needed
    local ver
    ver="$(get_schema_version)"

    # DBs without schema_version table but with tasks table are v1
    if [[ "$ver" -eq 0 ]] && table_exists "tasks"; then
        ensure_schema_version_table
        sql "INSERT OR REPLACE INTO schema_version (id, version) VALUES (1, 1);"
        ver=1
    fi

    if [[ "$ver" -lt 2 ]]; then
        backup_db
        migrate_to_v2
    fi
}

# SQLite with WAL mode and busy timeout for concurrent access
# PRAGMAs output suppressed via .output, then restored for actual query
sql() { sqlite3 -batch -noheader -cmd ".output /dev/null" -cmd "PRAGMA busy_timeout = 5000;" -cmd "PRAGMA journal_mode = WAL;" -cmd ".output stdout" "$DB_FILE" "$@"; }
sql_pretty() { sqlite3 -batch -header -column -cmd ".output /dev/null" -cmd "PRAGMA busy_timeout = 5000;" -cmd "PRAGMA journal_mode = WAL;" -cmd ".output stdout" "$DB_FILE" "$@"; }

status_icon() {
    case "$1" in
        todo) echo "○" ;; in_progress) echo "◐" ;; blocked) echo "⊘" ;;
        done) echo "✓" ;; cancelled) echo "✗" ;; *) echo "?" ;;
    esac
}

# Normalize status aliases (wip→in_progress, drop/cancel→cancelled)
normalize_status() {
    case "$1" in
        todo) echo "todo" ;;
        wip|in_progress) echo "in_progress" ;;
        blocked) echo "blocked" ;;
        done) echo "done" ;;
        drop|cancel|cancelled) echo "cancelled" ;;
        *) echo "" ;;
    esac
}

normalize_priority() {
    case "$1" in
        low) echo "low" ;; medium) echo "medium" ;; high) echo "high" ;; critical) echo "critical" ;; *) echo "" ;;
    esac
}

validate_status() {
    local s; s=$(normalize_status "$1")
    [[ -n "$s" ]] || die "invalid status '$1' (todo, in_progress, blocked, done, cancelled)"
}

validate_priority() {
    local p; p=$(normalize_priority "$1")
    [[ -n "$p" ]] || die "invalid priority '$1' (low, medium, high, critical)"
}

escape() { printf '%s' "$1" | sed "s/'/''/g"; }

now() { date +%s; }

relative_time() {
    local ts=$1
    local now_ts; now_ts=$(now)
    local diff=$((now_ts - ts))
    if ((diff < 60)); then echo "just now"
    elif ((diff < 3600)); then echo "$((diff / 60))m ago"
    elif ((diff < 86400)); then echo "$((diff / 3600))h ago"
    elif ((diff < 604800)); then echo "$((diff / 86400))d ago"
    elif ((diff < 2592000)); then echo "$((diff / 604800))w ago"
    else echo "$((diff / 2592000))mo ago"
    fi
}

fmt_ts() {
    # Format timestamp as "YYYY-MM-DD HH:MM  (relative)"
    local ts=$1
    [[ -z "$ts" || "$ts" == "0" ]] && return
    echo "$(date -r "$ts" '+%Y-%m-%d %H:%M')  ($(relative_time "$ts"))"
}

# ─────────────────────────────────────────────────────────────────
# Database (v2 schema with CHECK constraints)
# ─────────────────────────────────────────────────────────────────
init_db() {
    sql <<'SQL'
CREATE TABLE IF NOT EXISTS schema_version (
    id INTEGER PRIMARY KEY DEFAULT 1 CHECK (id = 1),
    version INTEGER NOT NULL
);

CREATE TABLE IF NOT EXISTS tasks (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    title TEXT NOT NULL,
    description TEXT,
    status TEXT NOT NULL DEFAULT 'todo'
        CHECK(status IN ('todo','in_progress','blocked','done','cancelled')),
    priority TEXT DEFAULT 'medium'
        CHECK(priority IN ('low','medium','high','critical')),
    tags TEXT,
    parent_id INTEGER,
    created_at INTEGER NOT NULL,
    updated_at INTEGER NOT NULL,
    completed_at INTEGER,
    FOREIGN KEY (parent_id) REFERENCES tasks(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_parent ON tasks(parent_id);
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON tasks(priority);

INSERT OR REPLACE INTO schema_version (id, version) VALUES (1, 2);
SQL
}

# ─────────────────────────────────────────────────────────────────
# Commands
# ─────────────────────────────────────────────────────────────────

cmd_create() {
    local title="" status="todo" priority="medium" description="" parent_id=""
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --status) shift; validate_status "$1"; status="$(normalize_status "$1")" ;;
            --priority) shift; validate_priority "$1"; priority="$(normalize_priority "$1")" ;;
            --description) shift; description="$1" ;;
            --parent) shift; parent_id="$1" ;;
            -*) die "unknown option: $1" ;;
            *) [[ -z "$title" ]] && title="$1" || die "unexpected argument: $1" ;;
        esac
        shift
    done
    
    [[ -n "$title" ]] || die "usage: phi_epsilon create <title> [--status STATUS] [--priority PRIORITY] [--description TEXT] [--parent ID]"
    
    local ts; ts=$(now)
    local sql_desc="NULL"
    local sql_parent="NULL"
    [[ -n "$description" ]] && sql_desc="'$(escape "$description")'"
    [[ -n "$parent_id" ]] && sql_parent="$parent_id"
    
    local id
    id=$(sql "INSERT INTO tasks (title, description, status, priority, parent_id, created_at, updated_at)
              VALUES ('$(escape "$title")', $sql_desc, '$status', '$priority', $sql_parent, $ts, $ts)
              RETURNING id;")
    
    local icon; icon=$(status_icon "$status")
    echo "created #${id}: ${icon} [${priority}] ${title}"
}

cmd_list() {
    local statuses=() priority="" tag="" parent="" limit=50 show_all=false
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --status) shift; validate_status "$1"; statuses+=("$(normalize_status "$1")") ;;
            --filter) 
                shift
                # Parse comma-separated status names: --filter todo,in_progress,done
                IFS=',' read -ra tokens <<< "$1"
                for t in "${tokens[@]}"; do
                    validate_status "$t"
                    statuses+=("$(normalize_status "$t")")
                done
                ;;
            --priority) shift; validate_priority "$1"; priority="$(normalize_priority "$1")" ;;
            --tag) shift; tag="$1" ;;
            --parent) shift; parent="$1" ;;
            --limit) shift; limit="$1" ;;
            --all) show_all=true ;;
            -*) die "unknown option: $1" ;;
            *) die "unexpected argument: $1" ;;
        esac
        shift
    done
    
    # Default: active tasks only
    if [[ ${#statuses[@]} -eq 0 ]] && [[ "$show_all" == false ]]; then
        statuses=("todo" "in_progress" "blocked")
    fi
    
    local where="1=1"
    if [[ ${#statuses[@]} -gt 0 ]]; then
        local status_list=""
        for s in "${statuses[@]}"; do status_list+="'$s',"; done
        status_list="${status_list%,}"
        where="$where AND status IN ($status_list)"
    fi
    [[ -n "$priority" ]] && where="$where AND priority = '$priority'"
    [[ -n "$tag" ]] && where="$where AND (',' || tags || ',' LIKE '%,$tag,%')"
    [[ -n "$parent" ]] && where="$where AND parent_id = $parent"
    
    sql "SELECT id, status, priority, title, tags FROM tasks WHERE $where ORDER BY 
         CASE status WHEN 'in_progress' THEN 1 WHEN 'blocked' THEN 2 WHEN 'todo' THEN 3 WHEN 'done' THEN 4 ELSE 5 END,
         CASE priority WHEN 'critical' THEN 1 WHEN 'high' THEN 2 WHEN 'medium' THEN 3 ELSE 4 END,
         id DESC LIMIT $limit;" | while IFS='|' read -r id status priority title tags; do
        local icon; icon=$(status_icon "$status")
        local tag_str=""
        [[ -n "$tags" ]] && tag_str=" [${tags}]"
        echo "${icon} #${id} [${priority}] ${title}${tag_str}"
    done
}

cmd_get() {
    local id="${1:-}"
    [[ -n "$id" ]] || die "usage: phi_epsilon get <id>"
    
    local row
    row=$(sql "SELECT id, title, description, status, priority, tags, parent_id, created_at, updated_at, completed_at
               FROM tasks WHERE id = $id;")
    [[ -n "$row" ]] || die "task #$id not found" $EXIT_NOT_FOUND
    
    IFS='|' read -r id title desc status priority tags parent_id created updated completed <<< "$row"
    
    local icon; icon=$(status_icon "$status")
    
    # Header
    echo "${icon} #${id} [${priority}] ${title}"
    echo "  ─────────────────────────────────────────────"
    
    # Metadata fields (aligned)
    printf "  %-12s%s\n" "status" "$status"
    printf "  %-12s%s\n" "priority" "$priority"
    [[ -n "$created" && "$created" != "0" ]] && printf "  %-12s%s\n" "created" "$(fmt_ts "$created")"
    [[ -n "$updated" && "$updated" != "0" ]] && printf "  %-12s%s\n" "updated" "$(fmt_ts "$updated")"
    [[ -n "$completed" && "$completed" != "0" ]] && printf "  %-12s%s\n" "completed" "$(fmt_ts "$completed")"
    [[ -n "$tags" ]] && printf "  %-12s%s\n" "tags" "$tags"
    [[ -n "$parent_id" ]] && printf "  %-12s%s\n" "parent" "#$parent_id"
    
    # Description
    if [[ -n "$desc" ]]; then
        echo "  ─────────────────────────────────────────────"
        echo "  $desc"
    fi
    
    # Subtasks
    local subtasks
    subtasks=$(sql "SELECT id, status, priority, title FROM tasks WHERE parent_id = $id ORDER BY id;")
    if [[ -n "$subtasks" ]]; then
        echo "  ─────────────────────────────────────────────"
        echo "  subtasks:"
        echo "$subtasks" | while IFS='|' read -r sid sstatus spri stitle; do
            local sicon; sicon=$(status_icon "$sstatus")
            echo "    ${sicon} #${sid} [${spri}] ${stitle}"
        done
    fi
}

cmd_update() {
    local id="" status="" priority="" title="" description=""
    
    [[ $# -gt 0 ]] && { id="$1"; shift; }
    [[ -n "$id" ]] || die "usage: phi_epsilon update <id> [--status STATUS] [--priority PRIORITY] [--title TEXT] [--description TEXT]"
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --status) shift; validate_status "$1"; status="$(normalize_status "$1")" ;;
            --priority) shift; validate_priority "$1"; priority="$(normalize_priority "$1")" ;;
            --title) shift; title="$1" ;;
            --description) shift; description="$1" ;;
            -*) die "unknown option: $1" ;;
            *) die "unexpected argument: $1" ;;
        esac
        shift
    done
    
    local sets="updated_at = $(now)"
    [[ -n "$status" ]] && sets="$sets, status = '$status'"
    [[ -n "$priority" ]] && sets="$sets, priority = '$priority'"
    [[ -n "$title" ]] && sets="$sets, title = '$(escape "$title")'"
    [[ -n "$description" ]] && sets="$sets, description = '$(escape "$description")'"
    
    # Set completed_at when marking done
    [[ "$status" == "done" ]] && sets="$sets, completed_at = $(now)"
    
    local result
    result=$(sql "UPDATE tasks SET $sets WHERE id = $id RETURNING id, status, priority, title;")
    [[ -n "$result" ]] || die "task #$id not found" $EXIT_NOT_FOUND
    
    IFS='|' read -r rid rstatus rpri rtitle <<< "$result"
    local icon; icon=$(status_icon "$rstatus")
    echo "updated ${icon} #${rid} [${rpri}] ${rtitle}"
}

cmd_done() {
    local id="${1:-}"
    [[ -n "$id" ]] || die "usage: phi_epsilon done <id>"
    
    local ts; ts=$(now)
    local result
    result=$(sql "UPDATE tasks SET status = 'done', completed_at = $ts, updated_at = $ts 
                  WHERE id = $id RETURNING id, priority, title;")
    [[ -n "$result" ]] || die "task #$id not found" $EXIT_NOT_FOUND
    
    IFS='|' read -r rid rpri rtitle <<< "$result"
    echo "updated ✓ #${rid} [${rpri}] ${rtitle}"
}

cmd_delete() {
    local id="${1:-}"
    [[ -n "$id" ]] || die "usage: phi_epsilon delete <id>"
    
    local title
    title=$(sql "SELECT title FROM tasks WHERE id = $id;")
    [[ -n "$title" ]] || die "task #$id not found" $EXIT_NOT_FOUND
    
    sql "DELETE FROM tasks WHERE id = $id;"
    echo "deleted #${id}: ${title}"
}

cmd_tag() {
    local id="${1:-}" tag="${2:-}"
    [[ -n "$id" && -n "$tag" ]] || die "usage: phi_epsilon tag <id> <tag>"
    
    local current
    current=$(sql "SELECT tags FROM tasks WHERE id = $id;")
    [[ -n "$current" || $? -eq 0 ]] || die "task #$id not found" $EXIT_NOT_FOUND
    
    # Check if tag already exists
    if [[ ",$current," == *",$tag,"* ]]; then
        echo "task #$id already has tag '$tag'"
        return 0
    fi
    
    local new_tags
    [[ -n "$current" ]] && new_tags="${current},${tag}" || new_tags="$tag"
    
    sql "UPDATE tasks SET tags = '$new_tags', updated_at = $(now) WHERE id = $id;"
    echo "tagged #$id with '$tag'"
}

cmd_untag() {
    local id="${1:-}" tag="${2:-}"
    [[ -n "$id" && -n "$tag" ]] || die "usage: phi_epsilon untag <id> <tag>"
    
    local current
    current=$(sql "SELECT tags FROM tasks WHERE id = $id;")
    
    # Remove tag from comma-separated list
    local new_tags
    new_tags=$(echo "$current" | tr ',' '\n' | grep -v "^${tag}$" | tr '\n' ',' | sed 's/,$//')
    
    sql "UPDATE tasks SET tags = '$new_tags', updated_at = $(now) WHERE id = $id;"
    echo "removed tag '$tag' from #$id"
}

cmd_tags() {
    sql "SELECT DISTINCT value FROM tasks, json_each('[\'' || replace(tags, ',', ''\'','\''') || ''\'']') 
         WHERE tags IS NOT NULL AND tags != '' ORDER BY value;" 2>/dev/null || \
    sql "SELECT tags FROM tasks WHERE tags IS NOT NULL AND tags != '';" | tr ',' '\n' | sort -u
}

cmd_info() {
    echo "Database: $DB_FILE"
    echo ""
    sql_pretty "SELECT 
        COUNT(*) AS total,
        SUM(CASE WHEN status='todo' THEN 1 ELSE 0 END) AS todo,
        SUM(CASE WHEN status='in_progress' THEN 1 ELSE 0 END) AS in_progress,
        SUM(CASE WHEN status='blocked' THEN 1 ELSE 0 END) AS blocked,
        SUM(CASE WHEN status='done' THEN 1 ELSE 0 END) AS done,
        SUM(CASE WHEN status='cancelled' THEN 1 ELSE 0 END) AS cancelled
    FROM tasks;"
    echo ""
    echo "Status:   ○todo  ◐in_progress  ⊘blocked  ✓done  ✗cancelled"
    echo "Priority: low  medium  high  critical"
}

cmd_help() {
    cat <<'EOF'
phi_epsilon - Task management CLI

USAGE: phi_epsilon <command> [args] [options]

STATUS:   todo | in_progress | blocked | done | cancelled
PRIORITY: low | medium | high | critical
ALIASES:  wip → in_progress, drop/cancel → cancelled

COMMANDS (status commands: no ID=list, with ID=transition):
  todo [ID]       List todo tasks OR mark ID as todo
  wip [ID]        List wip tasks OR mark ID as wip      (alias: start)
  done [ID]       List done tasks OR mark ID as done    (alias: finish)
  drop [ID]       List dropped OR mark ID as dropped    (alias: x, cancel)

  add <title>     Create task
                  --priority PRIORITY  --status STATUS  --parent ID  --description TEXT
  get <id>        Show task details                     (alias: show)
  update <id>     Modify task                           (alias: set)
                  --priority PRIORITY  --status STATUS  --title TEXT  --description TEXT
  rm <id>         Delete task                           (alias: delete)

  list            List tasks (default: active only)     (alias: ls)
                  --status STATUS  --filter S,S  --priority PRIORITY  --tag TAG
                  --parent ID  --limit N  --all
  backlog [N]     wip + todo by priority (default 50)
  next            Single highest-priority todo
  active          todo + wip + blocked
  all [N]         All tasks including done/dropped

  tag <id> <t>    Add tag
  untag <id> <t>  Remove tag
  tags            List all tags
  info            Database stats

OUTPUT: {icon} #{id} [{priority}] {title} [{tags}]

EXAMPLES:
  phi_epsilon add "Fix bug" --priority high
  phi_epsilon wip 42 && phi_epsilon done 42
  phi_epsilon list --tag backend --priority critical
  phi_epsilon list --filter todo,in_progress
  phi_epsilon update 1 --status blocked --priority high
  phi_epsilon todo --limit 100

ENV: PHI_EPSILON_DATA_DIR overrides ~/.local/share/phi/projects/<project>/
EOF
}

# ─────────────────────────────────────────────────────────────────
# Main
# ─────────────────────────────────────────────────────────────────
# Unified status commands: list if no ID, transition if ID given
cmd_todo() {
    if [[ "${1:-}" =~ ^[0-9]+$ ]]; then
        cmd_update "$1" --status todo
    else
        cmd_list --status todo "$@"
    fi
}

cmd_wip() {
    if [[ "${1:-}" =~ ^[0-9]+$ ]]; then
        cmd_update "$1" --status in_progress
    else
        cmd_list --status in_progress "$@"
    fi
}

cmd_done_or_list() {
    if [[ "${1:-}" =~ ^[0-9]+$ ]]; then
        cmd_done "$1"
    else
        cmd_list --status done "$@"
    fi
}

cmd_drop() {
    if [[ "${1:-}" =~ ^[0-9]+$ ]]; then
        cmd_update "$1" --status cancelled
    else
        cmd_list --status cancelled "$@"
    fi
}

cmd_next() {
    # Show highest priority todo task
    sql "SELECT id, status, priority, title FROM tasks 
         WHERE status = 'todo'
         ORDER BY CASE priority WHEN 'critical' THEN 1 WHEN 'high' THEN 2 WHEN 'medium' THEN 3 ELSE 4 END,
                  id ASC
         LIMIT 1;" | while IFS='|' read -r id status priority title; do
        echo "○ #${id} [${priority}] ${title}"
    done
}

cmd_backlog() {
    local limit="${1:-50}"
    # Show wip first, then todo, ordered by priority within each status
    sql "SELECT id, status, priority, title, tags FROM tasks 
         WHERE status IN ('in_progress', 'todo')
         ORDER BY 
           CASE status WHEN 'in_progress' THEN 1 WHEN 'todo' THEN 2 END,
           CASE priority WHEN 'critical' THEN 1 WHEN 'high' THEN 2 WHEN 'medium' THEN 3 ELSE 4 END,
           id DESC
         LIMIT $limit;" | while IFS='|' read -r id status priority title tags; do
        local icon; icon=$(status_icon "$status")
        local tag_str=""
        [[ -n "$tags" ]] && tag_str=" [${tags}]"
        echo "${icon} #${id} [${priority}] ${title}${tag_str}"
    done
}

main() {
    local cmd="${1:-help}"
    [[ $# -gt 0 ]] && shift
    
    case "$cmd" in
        # Core commands
        create|add|new) ensure_db; cmd_create "$@" ;;
        list|ls) ensure_db; cmd_list "$@" ;;
        get|show) ensure_db; cmd_get "$@" ;;
        update|set) ensure_db; cmd_update "$@" ;;
        delete|rm) ensure_db; cmd_delete "$@" ;;
        tag) ensure_db; cmd_tag "$@" ;;
        untag) ensure_db; cmd_untag "$@" ;;
        tags) ensure_db; cmd_tags ;;
        info) ensure_db; cmd_info ;;
        help|--help|-h) cmd_help ;;
        
        # 4 main status commands: list OR transition
        todo) ensure_db; cmd_todo "$@" ;;            # list todo OR mark as todo
        wip|start) ensure_db; cmd_wip "$@" ;;        # list wip OR mark as wip
        done|finish) ensure_db; cmd_done_or_list "$@" ;;  # list done OR mark as done
        drop|x|cancel) ensure_db; cmd_drop "$@" ;;   # list cancelled OR cancel
        
        # Extra list shortcuts
        active) ensure_db; cmd_list --filter todo,in_progress,blocked "$@" ;;
        all) ensure_db; cmd_list --all "$@" ;;
        next) ensure_db; cmd_next ;;
        backlog) ensure_db; cmd_backlog "$@" ;;
        
        *) die "unknown command: $cmd" ;;
    esac
}

main "$@"
